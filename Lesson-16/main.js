// Задание 1

// имя и фамилия должны состоять только из англ. букв и быть длиной (каждая часть) от 3 до 10 символов, между ними _ обязательно
// регистр учитываться не должен
// [a-z]{3,10}_[a-z]{3,10}
// /^[a-z]{3,10}_[a-z]{3,10}$/i

// далее опциональная часть, начинающаяся с тире и состоящая из 4-х цифр
// (-\d{4})?
// /^[a-z]{3,10}_[a-z]{3,10}(-\d{4})?$/i

// затем обязательный знак @
// @
// /^[a-z]{3,10}_[a-z]{3,10}(-\d{4})?@$/i

// название почтового сервиса должно быть длиной от 2-х до 20-ти символов, может состоять из букв английского алфавита и цифр,
// а также опционально может содержать в центре себя одно тире или одну точку
// [a-z0-9]{1,10}[-.]?[a-z0-9]{1,10}
// /^[a-z]{3,10}_[a-z]{3,10}(-\d{4})?@[a-z0-9]{1,10}[-.]?[a-z0-9]{1,10}$/i

// обязательная часть .com
// экранируем точку, так как она сама по себе в регулярном выражении обозначает - абсолютно любой символ
// \.com

// результат
/^[a-z]{3,10}_[a-z]{3,10}(-\d{4})?@[a-z0-9]{1,10}[-.]?[a-z0-9]{1,10}\.com$/i

// тестируем строку с применением метода test(str)*:
/^[a-z]{3,10}_[a-z]{3,10}(-\d{4})?@[a-z0-9]{1,10}[-.]?[a-z0-9]{1,10}\.com$/i.test('name_surname-1234@gmail.com')

// сделать так, чтобы точка или тире, указанные выше, могли содержаться в любом месте внутри почтового сервиса, кроме начала и конца *
// рассматриваем 2 возможных варианта через оператор ИЛИ (|)
// 1. если в названии почтового сервиса будет точка или тире, тогда
//      выполняем опережающую проверку (?=.{3,21}$) перед шаблоном почтового сервиса, обеспечивающую соответствие длины почтового сервиса условию
//      (считает символы от начала подшаблона справа от опережающей проверки и до конца строки - до символа $):
//          от 3, т.к. название почтового сервиса должно быть длиной от 2-х символов + содержит в любом месте внутри 1 тире или 1 точку
//          до 21, т.к. название почтового сервиса должно быть длиной до 20-ти символов + содержит в любом месте внутри 1 тире или 1 точку
//      т.к. точка/тире находится внутри почтового сервиса длиной от 2-х до 20-ти символов,
//          то количество символов слева от точки/тире может быть от 1 (тогда справа от точки/тире - 19 символов) до 19 (тогда справа от точки - 1 символ) и наоборот
//          [a-z0-9]{1,19}[-.][a-z0-9]{1,19}
//          (?=.{3,21}$)[a-z0-9]{1,19}[-.][a-z0-9]{1,19}
// 2. если в названии почтового сервиса не будет точки или тире, тогда
//      почтовый сервис - длиной от 2-х до 20-ти символов и может состоять из букв английского алфавита и цифр
//          [a-z0-9]{2,20}
// ((?=.{3,21}$)[a-z0-9]{1,19}[-.][a-z0-9]{1,19}|[a-z0-9]{2,20})$
// /^[a-z]{3,10}_[a-z]{3,10}(-\d{4})?@((?=.{3,21}$)[a-z0-9]{1,19}[-.][a-z0-9]{1,19}|[a-z0-9]{2,20})$/i

// обязательная часть .com
// экранируем точку, так как она сама по себе в регулярном выражении обозначает - абсолютно любой символ
// \.com
// так как опережающая проверка длины почтового сервиса считает символы от начала подшаблона справа от себя и до конца строки (- до символа $), то к промежутку {3,21} нужно добавить 4 символа .com ({7,25}),
// это не сломает логику, так как часть .com обязательная и мы ее хардкодим (т.е. для соответствия шаблону строка обязательно будет содержать эти 4 символа)
// ((?=.{7,25}$)[a-z0-9]{1,19}[-.][a-z0-9]{1,19}|[a-z0-9]{2,20})\.com$

// результат *:
/^[a-z]{3,10}_[a-z]{3,10}(-\d{4})?@((?=.{7,25}$)[a-z0-9]{1,19}[-.][a-z0-9]{1,19}|[a-z0-9]{2,20})\.com$/i

// тестируем строку с применением метода test(str) *:
/^[a-z]{3,10}_[a-z]{3,10}(-\d{4})?@((?=.{7,25}$)[a-z0-9]{1,19}[-.][a-z0-9]{1,19}|[a-z0-9]{2,20})\.com$/i.test('name_surname-1234@gmail.com')



// Задание 2

// рассматриваем 2 варианта комбинации символов в начале номера, которые пропишем в скобках через оператор ИЛИ (|)
// 1 вариант - номер может начинаться с 375 (без 0)
//      + перед 375 - опциональный
//      экранируем +, так как он сам по себе в регулярном выражении обозначает - от 1 и более
//      \+?
//      после 375 может быть или не быть -
//      \+?375-?
// 2 вариант - номер может начинаться с 80
//      после 8 может быть или не быть -
//      8-?0
// (\+?375-?|8-?0)

// номер должен содержать один из кодов - 25, 29, 33, 44 либо 17
// осуществляем через оператор ИЛИ (|)
// после кода может быть или не быть -
// (25|29|33|44|17)-?

// основная часть номера не может начинаться с 0
// основная часть номера начинает с 3-ех цифр
// [1-9]\d{2}

// остальная часть номера - это 2 комбинации по 2 цифры, которые могут быть или не быть разделены -
// (-?\d{2}){2}

function checkPhoneNumber(str) {
    return /^(\+?375-?|8-?0)(25|29|33|44|17)-?[1-9]\d{2}(-?\d{2}){2}$/.test(str);
}

console.log(checkPhoneNumber('+375-25-777-77-77'));
console.log(checkPhoneNumber('375299999999'));
console.log(checkPhoneNumber('8-044-444-44-44'));
console.log(checkPhoneNumber('8033-6666666'));



// Задание 3

// 1_method
function countVowelLetters(text) {
    var vowelLettersArr = text.match(/[аеёиоуыэюяaeiouy]/ig);       // вызов match при наличии флага g возвращает обычный массив из всех совпадений
                                                                    // если match не нашёл совпадений, он возвращает не пустой массив, а именно null
    return (vowelLettersArr === null) ? 0 : vowelLettersArr.length; // длина массива из гласных - это и есть количество гласных, если нет совпадений - функция возвращает 0
}

console.log('Количество гласных в переданном тексте: ' + countVowelLetters('ЧЕТЫРЕ МОДЕЛИ использования метода .map() в JavaScript.')); // 19


// 2_method
function countVowelLetters(text) {

    return text.replace(/[^аеёиоуыэюяaeiouy]/ig, '').length; // чтобы заменить все совпадения в строке, нужно использовать для поиска регулярное выражение, причём обязательно с флагом g
}

console.log('Количество гласных в переданном тексте: ' + countVowelLetters('ЧЕТЫРЕ МОДЕЛИ использования метода .map() в JavaScript.')); // 19


// 3_method
function countVowelLetters(text) {

    return (text.split(/[аеёиоуыэюяaeiouy]/i).length)-1; // разбиваем строку в массив по любой гласной букве
                                                         // длина получившегося массива будет на 1 больше количества гласных
                                                         // даже если в начале (или в конце, или и в начале и в конце) строки есть гласная,
                                                         // то первый (или последний, или первый и последний) элемент(ы) массива будут пустой строкой, и .length будет их считать
                                                         // сочетание гласных работает следующим образом: 'химия' -> ['x', 'м', '', ''] (между гласными 1 пустая строка)

}

console.log('Количество гласных в переданном тексте: ' + countVowelLetters('ЧЕТЫРЕ МОДЕЛИ использования метода .map() в JavaScript.')); // 19

